#!/usr/bin/python

'''
UniFam_lib.py

Functions needed for UniFam pipeline.

Created by JJ Chai on 02/24/2014
Last modified 05/20/2014
Copyright (c) 2014 JJ Chai (ORNL). All rights reserved.

'''
# Import Python modules
from subprocess import Popen, PIPE, check_call, STDOUT
import ConfigParser
import sys, os
import re
import shutil
from datetime import datetime

# annotation fields 
annot_keys = ["org", "EC_name", "gene_name","OLN","ORF","full_name","GO_terms","KW"]
## =================================================================
## function to read the fna file of contig sequences into dictionary
## ================================================================
def read_fna(fna_file,trim=True,reverse=False):
    ''' Read .fna file with all DNA sequences, and return dictionary object: contigID => contigSeq
        Input:
        1. fna_file: input fna file
        2. trim: trim ID at first space
        3. reverse: if true, seq => ID, instead of ID => seq
        Output
        1. dictionary object
    '''
    fna = open(fna_file,'r')
    ## all the contigs in a list
    contigs = fna.read().split('\n>')
    fna.close()
    
    contigs[0] = contigs[0][1:] # trim '>' for the first contig
    # input contigs info: contigID => sequence for this contig
    input_info = dict()
    for contig in contigs:
        if trim:
            contigID = contig.split()[0] # ID of this contig
        else:
            contigID = contig.split("\n",1)[0] # full header
        contigSeq = contig.split("\n",1)[1] # its corresponding sequence
        contigSeq = re.sub("\r","",contigSeq) # remove windows style EOF

        if reverse: # contigSeq => contigID
            # what if two proteins have the same sequences??
            # store the corresponding IDs in a list
            contigSeq = re.sub("\n","",contigSeq) # remove unix style EOF
            if input_info.has_key(contigSeq):
                input_info[contigSeq].append(contigID)
            else:
                input_info[contigSeq] = [contigID]
        else:
            input_info[contigID] = contigSeq # link them together in the dictionary
    return input_info

def annot_header(annotFile, faaFile, outputFile, origFaaFile=""):
    ''' Transfer UniFam annotations from flat file to the headers of the proteins in faaFile. 
        If the IDs of the proteins in faaFile are different from those in origFaaFile, 
        check the protein sequences and change the IDs to conform with the origFaaFile.
        
        Input:  
        1. annotFile: flat annotation file generated by UniFam
        2. faaFile: fasta file of proteins used by hmmsearch in UniFam pipeline
        3. origFaaFile: if not "", also a protein fasta file but possibly with different protein IDs

        Output: 
        1. outputFile: new fasta file with annotation attached to the header lines
    '''
    if origFaaFile=="":
        origFaaFile = faaFile

    annot = read_annot(annotFile)
    fout = open(outputFile,'w')

    # faa dictionary object: trim ID, reverse order: seq => seqID.
    # TODO: what if two proteins have the same sequences but different names?
    faaInfo = read_fna(faaFile, True, True) 
    origFaaInfo = read_fna(origFaaFile,False,False) # original faa dictionary, no trimming, normal order
    for key in sorted(origFaaInfo): # loop through all proteins in the original protein file
        seq = origFaaInfo[key] # sequence for this protein
        seq_no_interleave = re.sub("\n","",seq)
        seq_no_interleave = re.sub("\n","",seq_no_interleave)
        seq_annotated= False
        if faaInfo.has_key(seq_no_interleave):
            UniFam_proteinIDs = faaInfo[seq_no_interleave]
            # loop through all the proteinIDs with the sequence and see if any is annotated
            for UniFam_proteinID in UniFam_proteinIDs:
                if annot.has_key(UniFam_proteinID):
                    newAnnot = annot[UniFam_proteinID]
                    # write header line
                    fout.write('>{} # EC: {} # gene name: {} # product: {} # GO: {} \n'.format(key,newAnnot['ECname'], newAnnot['gene_name'], newAnnot['full_name'], newAnnot['GO']))
                    seq_annotated= True
                    break
            # sequence is not annotated
            if not seq_annotated:
                fout.write('>{} # not annotated\n'.format(key))
        # sequence is not found in the faa file
        else:
            fout.write('>{} # not found in {}. \n'.format(key, faaFile))
        # write sequence
        fout.write(seq+'\n')

    fout.close()
    
## =================================================================
## function to parse the .domtab output from hmmsearch
## find the best matching model(s) for a all the proteins in a genome
## ================================================================

def parse_domtabfile(domtabfile, outputfile, seq_coverage=0.5, hmm_coverage=0.5):
    ''' Parse the domain-wise table output from hmmsearch, find the best-matching
        models for all proteins in a genome.
        Things to consider:
        1) E-value
        2) Length of aligned region / total length of sequence and model > threshold (0.5).
        Order of the domains could be different because of domain shuffling.
        Hits that do not pass this threshold will not be considered.
        If nothing else passed the threshold, report no hit for this sequence
        3) what else?

        Input: domtabfile -- .domtab output
        
        Output: outputfile -- proteinID best_groupID E-value
        
        local dict to help: sequence -> model1:{E-value} model2:{E-value} ... modeln:{E-value}
    '''
    seq_dict = dict()
    min_coverage = min(seq_coverage,hmm_coverage)
    with open(domtabfile,'r') as domtab:
        for line in domtab:
            if line[0] == '#':
                continue # skip the lines starting with # - header or comments
            else:
                line = line.strip("\n").split()
                seq_name = line[0]
                seq_len = int(line[2])
                hmm_name = line[3]
                hmm_len = int(line[5])
                Eval = float(line[6])
                dom_ind = int(line[9]) # index of the current domain among all domains
                dom_tot = int(line[10])
                hmm_from = int(line[15])
                hmm_to = int(line[16])
                seq_from = int(line[17])
                seq_to = int(line[18])
                
                len_ratio = float(seq_len)/hmm_len
                # too short or too long
                if len_ratio > 1.0/min_coverage or len_ratio < min_coverage:
                    continue
                
                else:
                    if dom_ind == 1: # first of the many domains
                        #hit_dict = dict()
                        hmm_cover_vec = [0 for i in xrange(hmm_len)]
                        seq_cover_vec = [0 for i in xrange(seq_len)]
                        hmm_cover_vec[(hmm_from - 1): hmm_to] = [1 for i in xrange(hmm_from-1,hmm_to)]
                        seq_cover_vec[(seq_from - 1): seq_to] = [1 for i in xrange(seq_from-1,seq_to)]
                    
                    
                    else: # if it's not the first domain, update the coverage region
                        # to implement: interval_union
                        hmm_cover_vec[(hmm_from - 1): hmm_to] = [hmm_cover_vec[i] + 1 for i in xrange(hmm_from-1,hmm_to)]
                        seq_cover_vec[(seq_from - 1): seq_to] = [seq_cover_vec[i] + 1 for i in xrange(seq_from-1,seq_to)]
                    
                    if dom_ind == dom_tot: # all domains for this seq/model hit are read
                        
                        ## calculate coverage
                        hmm_cov = sum(i!=0 for i in hmm_cover_vec)/float(hmm_len)
                        seq_cov = sum(i!=0 for i in seq_cover_vec)/float(seq_len)
                        ## only push into dictionary if coverage passes the threshold
                        if hmm_cov >= hmm_coverage and seq_cov >= seq_coverage:
                            
                            ## whether sequence is already in the dictionary
                            if seq_name in seq_dict:
                                seq_dict[seq_name][hmm_name] = Eval
                            else:
                                seq_dict[seq_name] = {hmm_name:Eval}
    with open(outputfile,'w') as myout:
        for key in sorted(seq_dict):
            a = seq_dict[key]
            bestHMM = min(a,key=a.get)
            myout.write('%s\t%s\t%e\n' %(key, bestHMM, a.get(bestHMM)))

## =================================================================
## function to read annotation file for a database
## ================================================================
def read_annot(annot_file):
    ''' Read the annotation file, save in a dictionary and return.
        
        Input: annotation file, with fields: groupID, org, ECname, gene_name, OLN, ORF, full_name, GO, KW
               UPDATE - fields are now determined dynamically by the header line, instead of being fixed
                      - also only save the proteins with same groupID once
        
        Output: group_annot_dict - map from the first field (groupID or geneID, or something else) to annotations
    '''
    group_annot_dict = dict()
    header_dict = dict()
    header_line = ""
    with open(annot_file,'r') as annot:
        header_line = annot.readline()
        header = header_line.strip("\n").split("\t")
        n = len(header)
        for i in range(n):
            s = header[i]
            if "groupID" in s:
                header_dict['groupID']=i
            elif "org" in s:
                header_dict['org']=i
            elif "GO" in s:
                header_dict['GO']=i
            elif "EC" in s:
                header_dict['ECname']=i
            elif "gene_name" in s:
                header_dict['gene_name']=i
            elif "OLN" in s:
                header_dict['OLN']=i
            elif "ORF" in s:
                header_dict['ORF']=i
            elif "KW" in s:
                header_dict['KW']=i
            elif "full_name" in s:
                header_dict['full_name']=i
        for line in annot:
            if line != header_line:
                line = line.strip("\n").split("\t")
                # the key for the dictionary is whatever the first column contains
                group_annot_dict[line[0]] = \
                        {'ECname' : line[header_dict['ECname']], \
                        'groupID' : line[header_dict['groupID']], \
                        'org' : line[header_dict['org']], \
                        'OLN' : line[header_dict['OLN']], \
                        'ORF' : line[header_dict['ORF']], \
                        'gene_name' : line[header_dict['gene_name']], \
                        'full_name' : line[header_dict['full_name']], \
                        'GO' : line[header_dict['GO']], \
                        'KW' : line[header_dict['KW']]}
    return group_annot_dict

## =================================================================
## function to read RNAmmer output .gff file to memory
## ================================================================
def read_rnammer_gff(gffFile):
    ''' Read the annotation file, save in a dictionary and return.
        
        Input: gff file output from rnammer, seqname, start, end, score, attribute
        
        Output: dictionary object
    '''
    rrna_dict = dict()
    with open(gffFile,'r') as rrna:
        for line in rrna:
            if line[0] != "#":
                line = line.strip().split("\t")
                seqID = line[0].strip()
                start = int(line[3].strip())
                end = int(line[4].strip())
                score = float(line[5].strip())
                attr = line[-1].strip()
                if start < end:
                    region = str(start) + ".." + str(end)
                else:
                    region = "complement(" + str(end) + ".." + str(start) + ")"
                if rrna_dict.has_key(seqID):
                    rrna_dict[seqID].append({'region' : region, 'score' : score, 'attr' : attr})
                else:
                    rrna_dict[seqID] = [{'region' : region, 'score' : score, 'attr' : attr}]

    return rrna_dict

## =================================================================
## function to read RNAmmer output .gff file to memory
## ================================================================
def read_tRNAscan(tRNAfile):
    ''' Read the annotation file, save in a dictionary and return.
        
        Input: file output from tRNA-scan, seqname, start, end, tRNA type, anti Codon, Cove score
        
        Output: dictionary object
    '''
    trna_dict = dict()
    with open(tRNAfile,'r') as trna:
        for i in xrange(3): # skip the first 3 lines
            next(trna)
        for line in trna:
            line = line.strip().split("\t")
            seqID = line[0].strip()
            start = int(line[2].strip())
            end = int(line[3].strip())
            Type = line[4].strip()
            antiCodon = line[5].strip()
            CoveScore = float(line[8].strip())
            if start < end:
                region = str(start) + ".." + str(end)
            else:
                region = "complement(" + str(end) + ".." + str(start) + ")"
            if trna_dict.has_key(seqID):
                trna_dict[seqID].append({'region':region, 'Type':Type, 'antiCodon':antiCodon, 'CoveScore':CoveScore})
            else:
                trna_dict[seqID] = [{'region':region, 'Type':Type, 'antiCodon':antiCodon, 'CoveScore':CoveScore}]
    return trna_dict


## =================================================================
## function to read the group membership for proteins and save it
## to a dictionary; also save the number of proteins hit each group
## ================================================================
def read_groupfile(groupfile, Eval=0.00001):
    '''
        From groupfile (geneID groupID Eval) generated from parse_domtabfile,
        store the group membership for all genes in a dictionary, and
        store the occurence/abundance value of each UniFam group/cluster.
        
        Input:
        1.  groupfile - as described above, generated by parse_domtabfile

        Output:
        1.  protein_group_dict - map from geneID to its UniFam groupID
        2.  group_count_dict - map from UniFam groupID to its abundance value (integer)
    '''
    protein_group_dict = dict()
    group_count_dict = dict()
    with open(groupfile,'r') as group:
        for line in group:
            line = line.strip("\n").split()
            if "ID" not in line[0] and line[0][0] != "#":
                geneID = line[0]
                groupID = line[1]
                # Evalue is to be used for filtering
                if Eval > 0:
                    evalue = float(line[2])
                    if evalue > Eval: # if e-value is greater than the cutoff for identifying HMMs as hit
                        continue
                    else:
                        protein_group_dict[geneID] = groupID
                        if groupID in group_count_dict:
                            group_count_dict[groupID] += 1
                        else:
                            group_count_dict[groupID] = 1
                # Evalue is not used to filter search result
                else:
                    protein_group_dict[geneID] = groupID
                    if groupID in group_count_dict:
                        group_count_dict[groupID] += 1
                    else:
                        group_count_dict[groupID] = 1
    sys.stdout.write("Number of proteins annotated: {}\n".format(len(protein_group_dict)))
    return protein_group_dict, group_count_dict

## =================================================================
## function to annotate proteins
## ================================================================
def annot_proteins(protein_group_dict, annot, outputfile, Eval=0.00001):
    ''' 
        Annotate proteins from resulting groupfile
        
        Input: 
        1. protein_group_dict: map from proteinID to groupID
        2. annotation of groups from swissprot (annotation for UniFam_prok, UniFam_euk, or UniFam)
        3. Eval: e-value cutoff for HMM hits of sequences
        
        Output: flat file for protein annotation
    '''
    myannot = open(outputfile,'w')
    myannot.write("geneID\tgroupID\t")

    # use annot_keys instead of hard coded fields
    # so it can be more easily changed later on
    myannot.write("\t".join(annot_keys))
    myannot.write("\n")

    for geneID,groupID in protein_group_dict.iteritems():
        myannot.write('{0:}\t{1:}'.format(geneID,groupID))
        annot1 = annot[groupID]
        for annot_key in annot_keys:
            myannot.write('\t{0:}'.format(annot1.get(annot_key,"NA")))
        myannot.write("\n")
    
    myannot.close()

## =================================================================
## function to find the translation table used for gene calling in prodigal
## ================================================================
def transl_table(gffFile):
    ''' Input: gff/gbk format output generated by prodigal
        Output: transl_table number used for this genome
    '''
    with open(gffFile,'r') as fin:
        for line in fin:
            if line.find('transl_table') != -1:
                pos = line.find('transl_table')
                table_start = line.find('=',pos)
                table_end = line.find(';',pos)
                table_num = int(line[(table_start+1) : table_end])
                return table_num
        return -1

## =================================================================
## write organism_params.dat for one genome
#
#    This is an example:
#
#    ID      RHO
#    STORAGE FILE
#    NAME    Rhodococcus opacus B4
#    RANK    |strain|
#    PRIVATE?   NIL
#    CODON-TABLE     11
#    MITO-CODON-TABLE   1
#    DBNAME  RHOCyc
#    CREATE? t
#    DOMAIN  TAX-2
#    NCBI-TAXON-ID n
## =================================================================
def write_org_param(config):
    ''' generate organism_params.dat for a genome
        
        Input:
        1.  config: ConfigParser object from configuration file
        
        Output:
        1.  organism_params.dat: an input file for an organism 
            or multiple organisms in a metagenomic sample
    '''
    inputformat = config.get('UniFam','inputFormat')
    
    prefix = config.get('UniFam','name')
    workdir = config.get('UniFam','workDir') + '/'
    pathway_dir = workdir + prefix
    
    # set working directory for pathway analysis: pathway_dir, and save it in configuration file
    config.set('PathoLogic','pathwayDir',pathway_dir)
    # create directory to save the files for PathoLogic
    if not os.path.exists(pathway_dir):
        os.makedirs(pathway_dir)
    
    org_param_file = pathway_dir + "/organism-params.dat"
    org_param = open(org_param_file,'w') # output file handle

    # databse ID to store in ..../pgdbs/users/ for pathway-tools
    dbID = 'U' + prefix.upper()
    organism = config.get('PathoLogic','organism')

    ## write in organism-params.dat file
    org_param.write('{0:}\t{1:}\n'.format("ID",dbID)) #ID line
    org_param.write('{0:}\t{1:}\n'.format("STORAGE","FILE")) #STORAGE line
    org_param.write('{0:}\t{1:}\n'.format("NAME",organism)) #NAME line
    org_param.write('{0:}\t{1:}\n'.format("PRIVATE?","NIL")) #PRIVATE? set to NIL as default value
    org_param.write('{0:}\t{1:}\n'.format("RANK","|strain|")) #RANK line

    try:
        gffFile = config.get('prodigal','prodout')
        org_param.write('{0:}\t{1:}\n'.format("CODON-TABLE",transl_table(gffFile))) # CODON-TABLE line
    except ConfigParser.NoOptionError:
        org_param.write('{0:}\t{1:}\n'.format("CODON-TABLE",11)) # CODON-TABLE line

    org_param.write('{0:}\t{1:}\n'.format("DBNAME",dbID + "Cyc")) #DBNAME line
    org_param.write('{0:}\t{1:}\n'.format("CREATE?","t")) #CREATE? line

    # reset the database name in configuration file
    config.set('PathoLogic','dbName',dbID.lower()+"cyc")

    ## domain in taxonomy
    Domain = config.get('PathoLogic','domain')
    ## do not deal with viruses and uncategorized organisms
    if Domain == "bac":
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-2")) #DOMAIN line, bacteria
    elif Domain == "arc":
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-2157")) #DOMAIN line, archaea

    ## For now, only deal with prokaryotic genomes (this is not used, but probably in future)
    elif Domain == "euk":
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-2759")) #DOMAIN line, eukaryota
    else:
        org_param.write('{0:}\t{1:}\n'.format("DOMAIN","TAX-131567")) #DOMAIN line, biological orgainisms
    
    # NCBI-TAXON-ID line
    taxID = config.get('PathoLogic','taxID')
    if taxID != "unknown":
        org_param.write('{0:}\t{1:}\n'.format("NCBI-TAXON-ID",taxID)) #DOMAIN line
    ## finish writing the file
    org_param.close()

## =================================================================
## write the genetic-element.dat for a sample
## Also write corresponding .faa, .fna files
## ================================================================
def write_genetic_element_and_annot(config, annot, group_count_dict, annot_format="pf"):
    '''
        Write the file genetic-elements.dat (each entry describes one genetic element)
        Input:
        1.  config
        Output:
        1.  genetic-elements.dat
        2.  annotation file(s) with the given format
    '''
    pathway_dir = config.get('PathoLogic','pathwayDir')
    genetic_elem_file =  pathway_dir + "/genetic-elements.dat"
    genetic_elem = open(genetic_elem_file,'w')
    pf_file = pathway_dir + "/CONTIGS.pf"
    pf = open(pf_file, 'w')

    # Try to see if there is output (in gbk format) from prodigal
    # Get the element type for each contig if it's available.
    # Otherwise consider every thing as from a giant contig
    try:
        prod_outfile = config.get('prodigal','prodout')
    except ConfigParser.NoOptionError:
        prod_outfile = "NA"
        config.set('prodigal', 'prodout', "NA")
    if prod_outfile != "NA":
        contig_info = get_contig_info(prod_outfile)
        write_genetic_element_prod(genetic_elem, contig_info, annot_format)
        write_annot_prod(contig_info, annot_format)
    else:
        write_genetic_element_noSeq(genetic_elem, annot_format)
        write_annot_noSeq(annot, group_count_dict, pf, annot_format)

    pf.close()
    genetic_elem.close()

def get_contig_info(prod_outfile):
    '''
        From prodigal's output file, find the information of the contigs from which the proteins are called.
        Supposedly it should work for both gff format (default for prodigal3) and gbk format

        Input:
        1.  prod_outfile

        Output:
        1. contigs_info - map from contig's sequence number(in string) to its information,
                        including its id, sequence type, and circularity
    '''
    contigs_info = dict()
    seqnum = 0
    with open(prod_outfile) as prodout:
        for line in prodout:
            # in GenBank format:
            # DEFINITION  seqnum=1;seqlen=4367;seqhdr="gi|226315872|ref|NC_006969.2| Rhodococcus opacus B4 plasmid pKNR01, complete sequence";\
            # version=Prodigal.v2.60;run_type=Single;model="Ab initio";gc_cont=67.62;transl_table=11;uses_sd=1
            # in gff format:
            # # Sequence Data: seqnum=1;seqlen=5115410;seqhdr="Contig1"
            if line.startswith("DEFINITION") or line.startswith("# Sequence Data:"):
                ID_CDS_dict = dict()
                line = line.strip("\n")
                seq_num_index = line.find("seqnum=")
                seq_num_end = line.find(";",seq_num_index)
                seq_num = line[(seq_num_index + len("seqnum=")):seq_num_end]

                seq_hdr_index = line.find("seqhdr=")
                seq_hdr_end = line.find(";",seq_hdr_index)
                seq_hdr = line[(seq_hdr_index + len("seqhdr=")):seq_hdr_end]
                seq_hdr = seq_hdr.strip('"')
                
                # sequence Type:  plasmid, or complete genome or other (mitochondrial chromosome, chloroplast chromosome)
                if "plasmid" in seqhdr:
                    seqType = "PLASMID"
                elif "genome" in seqhdr or "chromosome" in seqhdr:
                    seqType = "CHRSM"
                else:
                    seqType = "CONTIG"

                # is the sequence circular (in other words, is it complete)?
                if "complete" in seqhdr:
                    circular = "Y"
                else:
                    circular = "N"
                
                contigs_info[seqnum] = {'seqID': seqhdr.split()[0], 'seqType': seqType, 'circular': circular, 'proteins':ID_CDS_dict}

            elif line.strip().startswith("CDS"):
                CDS_string = line.strip(' \n').split()[-1]
                note_line = prodout.readline()
                sindex = note_line.find("ID=")
                eindex = note_line.find(";",sindex)
                proteinID = note_line[(sindex + len("ID=")):eindex]
                contig_num, protein_num = proteinID.split("_")
                contigs_info[contig_num]['proteins'][protein_num] = CDS_string 
                
            else:
                continue

    return contigs_info

def write_genetic_element_noSeq(genetic_elem, annot_format="pf"):
    ''' generate the file "genetic-element.dat", and .gbk file, 
        when there is no contig information available, assume everything from 
        1 giant contig, even in metagenomic case. 

        Note that if hole filling and TIP is not performed, the contig sequences are not needed,
        and the coding coordinates probably don't matter either.
        
        Input:  1. output file object for genetic-elements.dat
                2. annot: annotation dictionary for all the groups in the specified UniFam database
                3. group_count_dict: map from groupID to number of proteins belong to this group
        Output: genetic-element.dat, *.gbk files for pathway reconstruction with pathway-tools
    '''
    genetic_elem.write('{0:}\t{1:}\n'.format("ID", "CONTIGS")) # id of this genetic element
    genetic_elem.write('{0:}\t:{1:}\n'.format("TYPE", "CONTIG")) # chromosome, or plasmid, or other
    genetic_elem.write('{0:}\t{1:}\n'.format("CIRCULAR?", "N")) #circular or not

    annot_file = "CONTIGS." + annot_format
    
    genetic_elem.write('{0:}\t{1:}\n'.format("ANNOT-FILE", annot_file)) #annotation file
    genetic_elem.write('{0:}\t{1:}\n'.format("SEQ-FILE", ' ')) #sequence file is not available in this case
    genetic_elem.write("//\n") # indicator of end of current genetic element

def write_genetic_element_prod(genetic_elem, contig_info, annot_format="pf"):
    '''     
        Write genetic-elements.dat file with the presence of prodigal's output file, 
        which provides more information about the contigs/sequences in the genome

        Input:
        1.  genetic_elem - file object to write the content 
        2.  contig_info
        3.  annot_format - annotation format, either .pf or .gbk

        Output:
        1.  write content to the genetic-elements.dat
    '''
    
    # counter for each type of sequence
    plasmidCt = 0
    chrsmCt = 0
    contigCt = 0
    
    for i in contigs_info:
        seqType = contigs_info[i]['seqType']
        seqID = contigs_info[i]['seqID']
        if seqType == "CHRSM":
            chrsmCt += 1
            element_id = seqType + "-" + str(chrsmCt)
        elif seqType == "PLASMID":
            plasmidCt += 1
            element_id = seqType + "-" + str(plasmidCt)
        else:
            contigCt += 1
            element_id = seqType + "-" + str(contigCt)

        genetic_elem.write('{0:}\t{1:}\n'.format("ID", element_id)) # id of this genetic element
        genetic_elem.write('{0:}\t:{1:}\n'.format("TYPE", seqType)) # chromosome, or plasmid, or other
        genetic_elem.write('{0:}\t{1:}\n'.format("CIRCULAR?", contigs_info[i]['circular'])) #circular or not

        annot_file = element_id + "." + annot_format
        contig_info[i]['annotFile'] = annot_file # add another attribute to the contig's information: annotation file name
        
        genetic_elem.write('{0:}\t{1:}\n'.format("ANNOT-FILE", annot_file)) #annotation file
        genetic_elem.write('{0:}\t{1:}\n'.format("SEQ-FILE", " ")) #sequence file
        genetic_elem.write("//\n") # indicator of end of current genetic element
        
def write_annot_prod(contig_info, prod_outfile, annot_format):
    ''' 
    '''
    # directory to store the files for pathologic
    pathway_dir = config.get('PathoLogic','pathwayDir')
    
    # annotation for the proteins, from the output annotation flat file
    annot = read_annot(outputAnnot)
    
    # read rRNA and tRNA output, TODO what if they do not exist?
    dotRNAscan = config.getboolean('UniFam','dotRNAscan')
    doRNAmmer = config.getboolean('UniFam','doRNAmmer')
    if dotRNAscan:
        tRNAoutput = config.get('tRNAscan','tRNAoutput')
        trna_dict = read_tRNAscan(tRNAoutput)
    if doRNAmmer:
        rRNAoutput = config.get('RNAmmer','rRNAoutput')
        rrna_dict = read_rnammer_gff(rRNAoutput)
    
    for contig_num in contigs_info:
        ## write the annotation file for this genetic element
        annot_out = open(pathway_dir + "/" + contigs_info[contig_num]['annot_file'],"w")
        proteins = contigs_info[contig_num]['proteins']
        for protein_num in proteins:
            protein_id = contig_num + "_" + protein_num
            write_annot(annot, protein_id, annot_out, annot_format, proteins[protein_num]) # TODO function to implement 
                
        annot_out.close()
        
        # check the rRNA annotation
        if doRNAmmer and rrna_dict.has_key(contig_num):
            rrna_list = rrna_dict[contig_num]
            write_rRNA(rrna_list,gbk)
        
        # check the tRNA annotation
        if dotRNAscan and trna_dict.has_key(contig_num):
            trna_list = trna_dict[contig_num]
            write_tRNA(trna_list,gbk)

def write_annot_noSeq(annot, group_count_dict, pf, annot_format="pf"):
    if annot_format != "pf":
        sys.stderr.write("When only proteins are given as input, gbk format annotation file is not available.\n")
    for group_id,count in group_count_dict.iteritems():
        if group_id in annot:
            write_pf_group(group_id, annot[group_id], count, pf)
        else:
            sys.stderr.write("{} is not in annot dict\n".format(group_id))

def write_annot(annot, protein_id, annot_out, annot_format, CDS="1..1000"): # TODO function to implement 
    if annot_format == "gbk":
        write_gbk(annot, protein_id, annot_out, CDS)
    elif annot_format == "pf":
        write_pf_protein(annot, protein_id, annot_out, CDS)
    else:
        sys.stderr.write("Specified annotation format {} is no valid/supported.\n".format(annot_format))

## =================================================================
## write gbk file for a contig/chromosome/plasmid,
## protein coding gene part
## =================================================================
def write_gbk(annot, protein_id, gbk, CDS="1..1000"):
    ''' Write a contig's protein annotation in the corresponding file
        Input:
            1. annot_prot: annotation for one protein
            2. count: number of proteins with the same annotation
            2. gbk: file object to write
    '''
    gbk.write("{0:5}CDS{0:13}{1}\n".format(' ',CDS)) # CDS line
    
    if protein_id in annot:
        annot_prot = annot[protein_id]
        ## ## /gene="gap",(required) /alt_name="gad", /alt_name="foo"
        gene_names = annot_prot["gene_name"].split(":")
        if gene_names[0] != "NA":
            gbk.write('{0:21}{1:}\n'.format(' ','/gene="' + gene_names[0] + '"'))
            for k in xrange(1,len(gene_names)):
                gbk.write('{0:21}{1:}\n'.format(' ','/alt_name="' + gene_names[k] + '"'))
        else: # if no gene name is available, write this line
            gbk.write('{0:21}/gene="{1:}"\n'.format(' ',protein_id))
        
        ## /EC_number="" (recommended)
        ECnames = annot_prot["ECname"].split(":")
        if ECnames[0] != "NA":
            for k in xrange(0,len(ECnames)):
                gbk.write('{0:21}{1:}\n'.format(' ','/EC_number="' + ECnames[k].strip("EC ") + '"'))
        
        ## /product="" (required) /product_comment="" (optional)
        product_names = annot_prot["full_name"].split(":")
        gbk.write('{0:21}{1:}\n'.format(' ','/product="' + product_names[0] + '"'))
        for k in xrange(1,len(product_names)):
            gbk.write('{0:21}{1:}\n'.format(' ','/product_comment="' + product_names[k] + '"'))
        
        ## /gene_comment="" (optional)
        ## include information from fields OLN, ORF, KW
        gene_comment = annot_prot["OLN"] + ":" + annot_prot["ORF"] + ":" + annot_prot["KW"]
        gene_comment = re.sub("NA:","",gene_comment)
        gene_comment = re.sub(":?NA","",gene_comment) # remove trailing NA, or :NA
        if gene_comment != "":
            gene_comment = re.sub(":",";\n" + " "*21, gene_comment)
            gbk.write('{0:21}{1:}\n'.format(' ','/gene_comment="' + gene_comment + '"'))
        
        ## /db_xref="GO:xxxxxx" (optional)
        GOs = annot_prot["GO"].split(":")
        if GOs[0] != "NA":
            for k in xrange(len(GOs)):
                gbk.write('{0:21}{1:}\n'.format(' ','/db_xref="GO:' + GOs[k] + '"'))
    else:
        gbk.write('{0:21}/gene="{1:}"\n'.format(' ',protein_id))
        gbk.write('{0:21}/product=""\n'.format(' '))
        gbk.write('{0:21}{1:}\n'.format(' ','/gene_comment="no annotation"'))

## =================================================================
## write pf (PathoLogic File) file for a contig/chromosome/plasmid,
## protein coding gene part
## =================================================================
def write_pf_protein(annot, protein_id, pf, CDS="1..1000"):
    # NAME line - Required
    pf.write("NAME\t")
    gene_names = annot_prot["gene_name"].split(":")
    if gene_names[0] != "NA":
        pf.write("{}\n".format(gene_names[0]))
    else:
        pf.write("{}\n".format(protein_id))

    # STARTBASE - Optional
    # ENDBASE - Optional
    bases = re.findall(r'\d+', CDS)
    if "complement" in CDS:
        STARTBASE = bases[-1]
        ENDBASE = bases[0]
    else:
        STARTBASE = bases[0]
        ENDBASE = bases[-1]
    
    # PRODUCT-TYPE - Required 
    #   P: protein **
    #   PSEUDO: pseudogene
    #   TRNA: tRNA
    #   RRNA: ribosomal RNA
    #   MISC-RNA: some other RNA such as can be part of various ribonuclear protein complexes
    pf.write("PRODUCT-TYPE\tP\n")

    if protein_id in annot:
        annot_prot = annot[protein_id]
        # ID line - highly recommended
        pf.write("ID\t")
        pf.write("{}\n".format(protein_id))

        # FUNCTION - Required assigned function of the product of the gene
        #            multifuncitonal proteins can have multiple lines
        product_names = annot_prot["full_name"].split(":")
        for k in xrange(len(product_names)):
            pf.write('FUNCTION\t{}\n'.format(product_names[k]))

        # SYNONYM - Optional additional synonyms a gene maybe known by
        if len(gene_names) > 1:
            for k in xrange(1, len(gene_names)):
                pf.write("SYNONYM\t{}\n".format(gene_names[k]))

        # EC - Recommended
        ECnames = annot_prot["ECname"].split(":")
        if ECnames[0] != "NA":
            for k in xrange(0,len(ECnames)):
                pf.write("EC\t{}\n".format(ECnames[k]))

        # GO - Recommended
        GOs = annot_prot["GO"].split(":")
        if GOs[0] != "NA":
            for k in xrange(len(GOs)):
                pf.write("DBLINK\tGO:{}\n".format(GOs[k]))

        # DBLINK - Optional 
        #   UNIPROT (SP) could be used since we have them for each group

        # GENE-COMMENT
        gene_comment = annot_prot["OLN"] + ":" + annot_prot["ORF"] + ":" + annot_prot["KW"]
        gene_comment = re.sub("NA:","",gene_comment)
        gene_comment = re.sub(":?NA","",gene_comment) # remove trailing NA, or :NA
        if gene_comment != "":
            gene_comment = re.sub(":","; ", gene_comment)
            pf.write("GENE-COMMENT\t{}\n".format(gene_comment))

        # ABUNDANCE - Optional
        #pf.write("ABUNDANCE\t{}\n".format(count))
    else:
        pf.write('FUNCTION\t{}\n'.format("ORF"))

    # indicate the end of a gene record
    pf.write("//\n") 

def write_pf_group(group_id, annot_prot, count, pf):
    # ID line - highly recommended
    pf.write("ID\t")
    pf.write("UniFam_{}\n".format(group_id))

    # NAME line - Required
    pf.write("NAME\t")
    gene_names = annot_prot["gene_name"].split(":")
    if gene_names[0] != "NA":
        pf.write("{}\n".format(gene_names[0]))
    else:
        pf.write("UniFam_{}\n".format(group_id))

    # STARTBASE - Optional
    # ENDBASE - Optional
    # FUNCTION - Required assigned function of the product of the gene
    #            multifuncitonal proteins can have multiple lines
    product_names = annot_prot["full_name"].split(":")
    for k in xrange(len(product_names)):
        pf.write('FUNCTION\t{}\n'.format(product_names[k]))

    # PRODUCT-TYPE - Required 
    #   P: protein **
    #   PSEUDO: pseudogene
    #   TRNA: tRNA
    #   RRNA: ribosomal RNA
    #   MISC-RNA: some other RNA such as can be part of various ribonuclear protein complexes
    pf.write("PRODUCT-TYPE\tP\n")

    # SYNONYM - Optional additional synonyms a gene maybe known by
    if len(gene_names) > 1:
        for k in xrange(1, len(gene_names)):
            pf.write("SYNONYM\t{}\n".format(gene_names[k]))

    # EC - Recommended
    ECnames = annot_prot["ECname"].split(":")
    if ECnames[0] != "NA":
        for k in xrange(0,len(ECnames)):
            pf.write("EC\t{}\n".format(ECnames[k]))

    # GO - Recommended
    GOs = annot_prot["GO"].split(":")
    if GOs[0] != "NA":
        for k in xrange(len(GOs)):
            pf.write("DBLINK\tGO:{}\n".format(GOs[k]))

    # DBLINK - Optional 
    #   UNIPROT (SP) could be used since we have them for each group

    # GENE-COMMENT
    gene_comment = annot_prot["OLN"] + ":" + annot_prot["ORF"] + ":" + annot_prot["KW"]
    gene_comment = re.sub("NA:","",gene_comment)
    gene_comment = re.sub(":?NA","",gene_comment) # remove trailing NA, or :NA
    if gene_comment != "":
        gene_comment = re.sub(":","; ", gene_comment)
        pf.write("GENE-COMMENT\t{}\n".format(gene_comment))

    # ABUNDANCE - Optional
    pf.write("ABUNDANCE\t{}\n".format(count))

    # indicate the end of a gene record
    pf.write("//\n") 

## =================================================================
## write gbk file for a contig/chromosome/plasmid,
## rRNA coding gene part
## =================================================================
def write_rRNA(rrna_list,gbk):
    ''' Write a contig's rRNA annotation in the corresponding file
        Input:
        1. rrna_list: annotation for all the rRNAs in this contig
        2. gbk: file object to write
    '''
    for i in xrange(len(rrna_list)):
        gbk.write('{0:>8}{1:13}{2:}\n'.format('rRNA',' ',rrna_list[i]['region'])) # rRNA  123..456
        gbk.write('{0:21}{1:}\n'.format(' ','/gene="' + rrna_list[i]['attr'] + '"')) # /gene="16S_rRNA"
        gbk.write('{0:21}{1:}\n'.format(' ','/note="hit to' + rrna_list[i]['attr'] + ' with score ' + str(rrna_list[i]['score']) + '"')) # /note="hit to 16S_rRNA with score 1735.1"
## =================================================================
## write gbk file for a contig/chromosome/plasmid,
## tRNA coding gene part
## =================================================================
def write_tRNA(trna_list,gbk):
    ''' Write a contig's tRNA annotation in the corresponding file
        Input:
        1. trna_list: annotation for all the tRNAs in this contig
        2. gbk: file object to write
        '''
    for i in xrange(len(trna_list)):
        gbk.write('{0:>8}{1:13}{2:}\n'.format('tRNA',' ',trna_list[i]['region'])) # tRNA  123..456
        gbk.write('{0:21}{1:}\n'.format(' ','/product="tRNA-' + trna_list[i]['Type'] + '"')) # /product="tRNA-Ile"
        gbk.write('{0:21}{1:}\n'.format(' ','/note="tRNA ' + trna_list[i]['Type'] + ' anticodon ' + trna_list[i]['antiCodon'] + ', Cove score ' + str(trna_list[i]['CoveScore']) + '"')) # /note="tRNA Ile anticodon GAT, Cove score 87.85, HMM score 62.4, structure score 25.45"
## =================================================================
## get prefix for prodigal command, input names will be filled in later
## =================================================================

def prodigalCmd(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    
    # working directory
    workdir = config.get('UniFam','workDir') + '/'
    
    faa = workdir + prefix + ".prod.faa"
    config.set('prodigal','faa',faa)
    prodigalPath = config.get('prodigal','prodigalPath')
    
    # output, *.prod.gbk
    output = workdir + prefix + ".prod.gbk"
    config.set('prodigal','prodout',output)
    # options that are accepted and used here for prodigal
    runOffEdge = config.getboolean('prodigal','runOffEdge')

    # now this is detected automatically by prodigal
    #translationTable = config.get('prodigal','translationTable')
    maskNs = config.getboolean('prodigal','maskNs')
    # single: single genome (normal), meta: meta genome (anon)
    procedure = config.get('prodigal','procedure')
    quiet = config.getboolean('prodigal','quiet')

    # prefix for the prodigal command, need to append input file to work
    prodigalCmdPrefix = prodigalPath + ' -a ' + faa  + (' -c' if not runOffEdge else '') + ' -f ' + 'gbk' +  ' -p ' + ('single' if procedure=='single' else 'meta')  + (' -q' if quiet else '') + ' -o ' + output

    return prodigalCmdPrefix

## =================================================================
## get prefix for hmmsearch command, input and output names will be filled in later
## =================================================================

def hmmCmd(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    
    # working directory
    workdir = config.get('UniFam','workDir') + '/'
    hmmsearchPath = config.get('hmmsearch','hmmsearchPath')
    
    # options for hmmsearch
    Eval = config.get('hmmsearch','eval')
    cpu = config.get('hmmsearch','cpu')
    domtb = workdir + prefix + '.domtab'
    
    config.set('hmmsearch','domtb',domtb)

    # save the output as specified if not default
    output = config.get('hmmsearch','output')
    if output!='' and output!='/dev/null':
        output = workdir + output
    
    database = config.get('UniFam','database')
    dataDir = config.get('UniFam','dataDir')

    # set reference annotation file, depending on the database chosen
    annotFile = "Annot_" + database
    config.set('UniFam','annotFile', annotFile)

    hmmsearchCmdPrefix = hmmsearchPath + ' -E ' + Eval +' --noali --cpu ' + cpu + ' --domtblout ' + domtb + ' -o ' + output + ' ' + dataDir + database + '.hmm'

    return hmmsearchCmdPrefix

## =================================================================
## get prefix for pathway-tools (PathoLogic) command
## =================================================================

def PathoLogicCmd(config):
    # pathway inference file directory
    pathway_dir = config.get('PathoLogic','pathwayDir') + "/"

    # path to pathway-tools executable
    PathoLogicPath = config.get('PathoLogic','PathoLogicPath')
    
    PathoLogic_Cmd = "%s -no-cel-overview -no-web-tip -no-patch-download -patho %s > /dev/null" %(PathoLogicPath,pathway_dir)
    
    return PathoLogic_Cmd

## =================================================================
## get prefix for rnammer command
## =================================================================

def run_RNAmmer(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    # full path of rnammer
    RNAmmer = config.get('RNAmmer','RNAmmerPath')
    # tmp working directory for RNAmmer
    tmpdir = config.get('UniFam','tmpDir') + '/'
    workDir = config.get('UniFam', 'workDir') + '/'
    # domain (superkingdom) for rnammer, bac, arc, or euk
    domain = config.get('PathoLogic','domain')
    # if working directory does not exist, create the directory
    if not os.path.exists(tmpdir):
        os.makedirs(tmpdir)
    # rnammer command line: .gff file should be the easiest to parse
    # /compgenpanfs/tools/rnammer/rnammer -S bac -T /chongle/jj/04_RNA/sample/ -m ssu,lsu,tsu -xml rrna.xml (-gff rrna.gff) -h rrna.hmm GCA_000018265.dna
    RNAmmer_CmdPrefix = "%s -S %s -T %s -m ssu,lsu,tsu -gff %s "%(RNAmmer, domain, tmpdir, workDir + prefix+".gff")
    config.set('RNAmmer','rRNAoutput', workDir + prefix + '.gff')
    return RNAmmer_CmdPrefix

## =================================================================
## get prefix for tRNA-scan command
## =================================================================

def run_tRNAscan(config):
    # common prefix for the output files
    prefix = config.get('UniFam','name')
    # full path of rnammer
    tRNAscanDir = config.get('tRNAscan','tRNAscanPath')
    # domain (superkingdom) for tRNAscan
    domain = config.get('PathoLogic','domain')
    # working directory
    workDir = config.get('UniFam','workDir') + '/'
    # command line option for the super kingdom
    if domain=="bac":
        domOpt = "-B"
    elif domain=="arc":
        domOpt = "-A"
    elif domain=="org":
        domOpt = "O"
    elif domain=="gen":
        domOpt = "G"
    elif domain=="euk":
        domOpt = ""
    else:
        domOpt = "-B"

    tRNAscan_CmdPrefix = "perl -I%s %stRNAscan-SE %s -o %s.tRNA.o -f %s.tRNA.structure -m %s.tRNA.stat -q "%(tRNAscanDir, tRNAscanDir, domOpt, workDir + prefix, workDir + prefix, workDir + prefix)
    dotRNAscan = config.getboolean('UniFam','dotRNAscan')
    if dotRNAscan:
        if os.path.exists(workDir + prefix + ".tRNA.o"):
            os.remove(workDir + prefix + ".tRNA.o")
        if os.path.exists(workDir + prefix + ".tRNA.structure"):
            os.remove(workDir + prefix + ".tRNA.structure")
        if os.path.exists(workDir + prefix + ".tRNA.stat"):
            os.remove(workDir + prefix + ".tRNA.stat")

    config.set('tRNAscan','tRNAoutput',workDir+prefix+'.tRNA.o')

    return tRNAscan_CmdPrefix
#perl -I/home/ml3/tRNAscan-SE /home/ml3/tRNAscan-SE/tRNAscan-SE -B -o tRNA.o -f tRNA.structure -m tRNA.stat -q GCA_000018265.dna
#tRNAscan-SE 1.3.1 (January 2012)
#
#FATAL: No sequence file(s) specified.
#
#Usage: tRNAscan-SE [-options] <FASTA file(s)>
#    
#    Scan a sequence file for tRNAs using tRNAscan, EufindtRNA &
#        tRNA covariance models
#            -- defaults to use with eukaryotic sequences
#                (use -B, -A, -O or -G to scan other types of sequences)
#
#Basic Options
#    -B         : search for bacterial tRNAs (use bacterial tRNA model)
#    -A         : search for archaeal tRNAs  (use archaeal tRNA model)
#    -O         : search for organellar (mitochondrial/chloroplast) tRNAs
#    -G         : use general tRNA model (cytoplasmic tRNAs from all 3 domains included)
#    
#    -i         : search using Infernal cm analysis only (max sensitivity, very slow)
#    -C         : search using Cove analysis only (high sensitivity, very slow)
#    
#    -o <file>  : save final results in <file>
#    -f <file>  : save tRNA secondary structures to <file>
#    -a         : output results in ACeDB output format instead of default
#        tabular format
#    -m <file>  : save statistics summary for run in <file>
#        (speed, # tRNAs found in each part of search, etc)
#    -H         : show both primary and secondary structure components to
#         covariance model bit scores
#    -q         : quiet mode (credits & run option selections suppressed)
#         
#    -h         : print full list (long) of available options

## =================================================================
## UniFam pipeline, for annotation
## =================================================================
def UniFam(inputfile, config, verbose=False):

    # common prefix for the output files
    prefix = config.get('UniFam','name')

    # replace any non-alphanumeric character or underscore to underscore
    prefix = re.sub(r'\W', r'_', prefix)
    config.set('UniFam', 'name', prefix)

    inputformat = config.get('UniFam','inputFormat') # get input format, contigs or proteins
    workdir = config.get('UniFam','workDir')
    outputAnnot = workdir + prefix + ".annot" # flat file with annotation for each protein
    outputfaa = workdir + prefix + '_annot.faa' # faa with annotation at the header lines
    

    # if working directory does not exist, create the directory
    if not os.path.exists(workdir):
        os.makedirs(workdir)
    readme = open(workdir+'README','w') # README file that describes output files
    readme.write("Working directory is {}\n".format(workdir))
    
    # starts with contigs, instead of proteins
    # run prodigal, RNAmmer, and tRNAscan
    if inputformat == "contigs":
        prodigalCmdPrefix = prodigalCmd(config)
        doProdigal = config.getboolean('UniFam','doProdigal')
        # change input file to the faa file generated by prodigal
        inputfaa = config.get('prodigal','faa')
        if doProdigal:
            prodigal_Cmd = prodigalCmdPrefix + ' -i ' + inputfile
            sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
            sys.stdout.write('[prodigal] >> Predicting genes using prodigal ... \n')
            if(verbose):
                sys.stdout.write("prodigal command: {}\n".format(prodigal_Cmd))
            prodigal_proc = Popen(prodigal_Cmd, shell = True, stdout=None, stderr=None)
            prodigal_status = prodigal_proc.wait()
            if prodigal_status != 0:
                sys.stderr.write('{} failed \n'.format(prodigal_Cmd))
            else:
                sys.stdout.write('[prodigal] >> prodigal gene calling finished. \n')
                readme.write("Prodigal predicted proteins are in file {}\n".format(os.path.basename(config.get('prodigal', 'faa'))))
                readme.write("Prodigal output in gbk format is {}\n".format(os.path.basename(config.get('prodigal', 'prodout'))))
            sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        else:
            sys.stdout.write('>> prodigal skipped. \n\n')


        # run rnammer
        doRNAmmer = config.getboolean('UniFam','doRNAmmer')
        if doRNAmmer:
            RNAmmer_CmdPrefix = run_RNAmmer(config)
            RNAmmer_Cmd = RNAmmer_CmdPrefix + inputfile
            sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
            sys.stdout.write('[RNAmmer] >> predicting rRNA with RNAmmer ... \n')
            if(verbose):
                sys.stdout.write("RNAmmer command: {}\n".format(RNAmmer_Cmd))
            RNAmmer_proc = Popen(RNAmmer_Cmd, shell = True, stdout=None, stderr=None)
            RNAmmer_status = RNAmmer_proc.wait()
            if RNAmmer_status != 0:
                sys.stderr.write('{} failed \n'.format(RNAmmer_Cmd))
            else:
                sys.stdout.write('[RNAmmer] >> rRNA prediction finished. \n')
                readme.write("RNAmmer output in gff format is {}\n".format(os.path.basename(config.get('RNAmmer', 'rRNAoutput'))))
            sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        else:
            sys.stdout.write('>> RNAmmer skipped. \n\n')

        # run tRNA-scan
        dotRNAscan = config.getboolean('UniFam','dotRNAscan')
        if dotRNAscan:
            tRNAscan_CmdPrefix = run_tRNAscan(config)
            tRNAscan_Cmd = tRNAscan_CmdPrefix + inputfile
            sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
            sys.stdout.write('[tRNAscan] >> predicting tRNA with tRNAscan ... \n')
            if(verbose):
                sys.stdout.write("tRNAscan command: {}\n".format(tRNAscan_Cmd))
            tRNAscan_proc = Popen(tRNAscan_Cmd, shell = True, stdout=None, stderr=None)
            tRNAscan_status = tRNAscan_proc.wait()
            
            if tRNAscan_status != 0:
                sys.stderr.write('{} failed \n'.format(tRNAscan_Cmd))
            else:
                sys.stdout.write('[tRNAscan] >> tRNA prediction finished. \n')
                readme.write("tRNAscan output is {}\n".format(os.path.basename(config.get('tRNAscan', 'tRNAoutput'))))

            sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        else:
            sys.stdout.write('>> tRNAscan skipped. \n\n')
        # parse the result
    else:
        inputfaa = inputfile

    # if starts with proteins, instead of contigs, gene calling is not necessary
    # hmmsearch against the database
    hmmsearchCmdPrefix = hmmCmd(config)
    doHMM = config.getboolean('UniFam','dohmmsearch')
    if doHMM:
        hmmsearchCmd = hmmsearchCmdPrefix + ' ' + inputfaa # hmmsearch system command
        sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
        sys.stdout.write('[hmmsearch] >> hmmsearch ... \n')
        if(verbose):
            sys.stdout.write("hmmsearch command: {}\n".format(hmmsearchCmd))
        hmm_proc = Popen(hmmsearchCmd, shell = True, stdout=None, stderr=None)
        hmm_status = hmm_proc.wait()
        
        if hmm_status != 0:
            sys.stderr.write('{} failed \n'.format(hmmsearchCmd))
        else:
            sys.stdout.write('[hmmsearch] >> hmmsearch finished. \n')
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
    else:
        sys.stdout.write('>> hmmsearch skipped. \n\n')

    # location of parseable domain table
    domtb = config.get('hmmsearch','domtb')

    doParse = config.getboolean('UniFam','doParse')

    # parse the domtab file
    group_file = workdir + prefix + '.group'
    protein_group_dict = dict()
    group_count_dict = dict()
    annot = dict()
    if doParse:
        sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
        sys.stdout.write('[UniFam] >> parsing hmmsearch results for best profile... \n')
        parse_domtabfile(domtb, group_file,seq_coverage=config.getfloat('UniFam','seqCoverage'), hmm_coverage=config.getfloat('UniFam','hmmCoverage'))
        sys.stdout.write('[UniFam] >> Annotating proteins... \n')
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time
        readme.write("hmmsearch result with proteinName, groupName, E-value is {}\n".format(os.path.basename(group_file)))
        # from parsing result (group_file), get the map from proteins to their UniFam groups
        protein_group_dict, group_count_dict = read_groupfile(group_file, Eval=config.getfloat('hmmsearch','eval'))

        # read annotation for the corresponding database
        annotFile = config.get('UniFam','dataDir') + config.get('UniFam','annotFile')
        annot = read_annot(annotFile)
        
        # generate output file (Annotation file in flat tab delimited format) in the working directory
        annot_proteins(protein_group_dict, annot, outputAnnot, Eval=config.getfloat('hmmsearch','eval'))
        # integrate annotation to the output fasta file
        annot_header(outputAnnot,inputfaa,outputfaa) 

        # update information in README file
        readme.write("Protein annotations as a flat file is {}\n".format(os.path.basename(outputAnnot)))
        readme.write("Fasta file of proteins with annotations in their header lines is {}\n".format(os.path.basename(outputfaa)))
    
    else:
        sys.stdout.write('>> Parsing skipped. \n\n')
    
    doPwy = config.getboolean('UniFam','doPathway')
    if doPwy:
        # If the input is not contigs, then the genomic sequence is missing, print warning message.
        if inputformat!="contigs":
            sys.stderr.write('** warning: {}\n'.format('Input format is not "contigs", find pathways using provided proteins'))
        
        sys.stdout.write("===== >> {} \n".format(str(datetime.now()))) # print current time
        sys.stdout.write('[UniFam] >> preparing files for pathway reconstruction... \n')
        write_org_param(config)
        if len(group_count_dict) == 0:
            protein_group_dict, group_count_dict = read_groupfile(outputAnnot,0)
        if len(annot) == 0:
            annotFile = config.get('UniFam','dataDir') + config.get('UniFam','annotFile')
            annot = read_annot(annotFile)

        write_genetic_element_and_annot(config, annot, group_count_dict, "pf")
        #genetic_element_gbk_noSeq(config, annot, group_count_dict, "pf")
        #if inputformat == "contigs":
        #    genetic_element_gbk_contigs(inputfile, config, outputAnnot)
        #else:
        #    genetic_element_gbk(config, outputAnnot)
        pwyCmd = PathoLogicCmd(config)
        sys.stdout.write('[Pathologic] >> Reconstructing pathways... \n')
        pwy_proc =Popen(pwyCmd, shell = True, stdout=None, stderr=None)
        pwy_status = pwy_proc.wait()
        if pwy_status != 0:
            sys.stderr.write('{} failed \n'.format(pwyCmd))
        else:
            sys.stdout.write('[Pathologic] >> Pathway reconstruction finished. \n')
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time

        ## move the pathway inference results to the working directory
        dbName = config.get('PathoLogic','dbName')
        pwyLocalDir = config.get('PathoLogic','PathwayLocalDir')
        shutil.move(pwyLocalDir+dbName,workdir+dbName)
        ## compress result with zip for user download
        dbzip = workdir+dbName+".zip"
        compressCmd = "zip -r " + dbzip + " " + workdir+dbName
        zip_proc = Popen(compressCmd, shell = True, stdout=None, stderr=None)
        zip_status = zip_proc.wait()
        if zip_status != 0:
            sys.stderr.write('{} failed \n'.format(compressCmd))
        else:
            sys.stdout.write('[UniFam] >> Pathway results compressed. \n')
            readme.write("Pathway inference result is in {}\n".format(os.path.basename(dbzip)))
        sys.stdout.write("===== >> {} \n\n".format(str(datetime.now()))) # print current time

    readme.close()
